# Lab3

## 练习1：理解基于 FIFO 的页面替换算法

## 练习2：深入理解不同分页模式的工作原理

> get_pte() 函数（位于 kern/mm/pmm.c）用于在页表中查找或创建页表项，从而实现对指定线性地址对应的物理页的访问和映射操作。这在操作系统中的分页机制下，是实现虚拟内存与物理内存之间映射关系非常重要的内容。  
函数`get_pte()`的定义如下：

```c
    pde_t *pdep1 = &pgdir[PDX1(la)];
    if (!(*pdep1 & PTE_V)) {
        struct Page *page;
        if (!create || (page = alloc_page()) == NULL) {
            return NULL;
        }
        set_page_ref(page, 1);
        uintptr_t pa = page2pa(page);
        memset(KADDR(pa), 0, PGSIZE);
        *pdep1 = pte_create(page2ppn(page), PTE_U | PTE_V);
    }
    pde_t *pdep0 = &((pde_t *)KADDR(PDE_ADDR(*pdep1)))[PDX0(la)];
//    pde_t *pdep0 = &((pde_t *)(PDE_ADDR(*pdep1)))[PDX0(la)];
    if (!(*pdep0 & PTE_V)) {
    	struct Page *page;
    	if (!create || (page = alloc_page()) == NULL) {
    		return NULL;
    	}
    	set_page_ref(page, 1);
    	uintptr_t pa = page2pa(page);
    	memset(KADDR(pa), 0, PGSIZE);
 //   	memset(pa, 0, PGSIZE);
    	*pdep0 = pte_create(page2ppn(page), PTE_U | PTE_V); //创建一个pte表项
    }
    return &((pte_t *)KADDR(PDE_ADDR(*pdep0)))[PTX(la)];
```

可见该函数主要完成的工作是根据给出的 PDT 基地址以及虚拟地址，找到对应的 PTE ，完成的方式为通过从虚拟地址中提取页目录索引 PDX 以及页表索引 PTX，从而依次找到页目录项 PDE 以及页表项 PTE。

> get_pte() 函数中有两段形式类似的代码，结合 sv32，sv39，sv48 的异同，解释这两段代码为什么如此相像。

`get_pte()`函数中的两段代码看起来非常相似，因为它们都在执行基本相似操作：检查页目录项 PDE （或页表项 PTE）是否存在，如果不存在并且`create`参数为1，则分配一个新的 PDE (或 PTE)，并设置新的PDE（或PTE）的值。对于页目录表的操作同页表的操作是类似的。  
这两段代码之间的主要区别在于它们操作的页目录级别不同。第一段代码处理的是第一级页目录，而第二段代码处理的是第二级页目录（也即页表）。  
在Sv32、Sv39和Sv48这三种虚拟内存方案中，都使用了多级页表来实现虚拟地址到物理地址的映射。Sv32使用两级页表，Sv39使用三级页表，而Sv48使用四级页表。每一级的页表都有一个对应的页目录，这些页目录项存储了下一级页表的物理地址整体的结构都是类似的，都是每个表有一些表项，每个表项指向下一级的表，所以，就会让每级之间的页表查询访问方式相似。

> 目前 get_pte() 函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？

`get_pte()`函数中，首先查询页目录表，再查询页表，从而得到一个 PTE ，在查询页目录表以及页表的过程中，如果表项不为valid，就会根据参数create来决定是否在缺失处创建一个新的表项，以此同时实现查询与分配页表项的功能。  
如果将查询以及分配的功能分开，可以想到，在分配一个页表项时，就需要对该页表项的位置进行查询，所以需要调用查询相关的函数。而查询函数可能会返回一个空的表项，而这个表项可能是 PTE ，也有可能是 PDE ，因为可能此时想要创建的页表项的页表所对应的页目录表项还未建立。这样，其返回结果既可能是需要创建的页表项，也有可能是其上一级的页目录表。从而需要做额外判断，造成逻辑上的复杂性。  
因此如果将函数拆分，最好创建一个函数单独在页目录表中搜索以及一个函数单独在页表中搜索。这样的逻辑是复杂的，我们也往往不需要单独搜索页目录表，而是同时搜索页目录表及其对应的页表。  
所以我们认为这样的写法很好，没有必要把两个函数拆开。

## 练习3：给未被映射的地址映射上物理页

## 练习4：补充完成 Clock 页替换算法

## 练习5：阅读代码和实现手册，理解页表映射方式相关知识

## Challenge：实现不考虑实现开销和效率的 LRU 页替换算法
