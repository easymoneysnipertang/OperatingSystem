# Lab3
- [Lab3](#lab3)
  - [练习1：理解基于 FIFO 的页面替换算法](#练习1理解基于-fifo-的页面替换算法)
    - [换入](#换入)
    - [换出](#换出)
  - [练习2：深入理解不同分页模式的工作原理](#练习2深入理解不同分页模式的工作原理)
  - [练习3：给未被映射的地址映射上物理页](#练习3给未被映射的地址映射上物理页)
  - [练习4：补充完成 Clock 页替换算法](#练习4补充完成-clock-页替换算法)
  - [练习5：阅读代码和实现手册，理解页表映射方式相关知识](#练习5阅读代码和实现手册理解页表映射方式相关知识)
    - [大页表优势](#大页表优势)
    - [大页表劣势](#大页表劣势)
  - [Challenge：实现不考虑实现开销和效率的 LRU 页替换算法](#challenge实现不考虑实现开销和效率的-lru-页替换算法)


## 练习1：理解基于 FIFO 的页面替换算法
### 换入
内存页的换入是在缺页中断处理程序中完成的，即由`do_pgfault`处理。该函数首先确定缺页的vma，接着调用`get_pte`得到该页对应的页表项。查看页表项是否存在过，没有则用`pgdir_alloc_page`新建页表项和其映射关系；否则调用`swap_in`从硬盘交换区中将该页读入内存中，然后`page_insert`更新页表项的内容。 

下面具体介绍一页被换入经过的处理：
1. `swap_in`函数首先调用`alloc_page`为即将被换入的页分配一页物理内存，该函数将在后续详细介绍，在此不赘述。
2. 接着调用`get_pte`函数根据给定的虚拟地址逐级找到对应的页表项，并返回页表项的地址。在这里由于是换入，所以之前已经存在页表项，故`create`设置为0，即不会在过程中新建页表。
3. 在`get_pte`逐级寻找时，涉及到换入页的主要是`PDX1`、`PDX0`、`PTX`等宏，这些宏负责从换入页的虚拟地址中拿出页目录项和页表项的索引。
4. 拿到页表项后，将页表项作为`swapfs_read`函数的参数传入，该函数接着调用`ide_read_secs`将交换区中的内存页`memcpy`进前面新分配的物理页。
5. 一个页在换出以后其页表项会保存`swap_entry`，便于换入的时候直接寻道磁盘。`swapfs_read`函数会通过`swap_offset`宏将`swap_entry`转为对应的偏移量。
6. 换入后还需要经过`page_insert`更新页表项：覆盖原来的页表项，保存新的映射关系。
7. 最后调用`swap_map_swappable`设置新换入的页是可以交换的。实际是调用`swap_mannager`对应的函数，在FIFO中即是将其插入到链表尾部，即最后一个进入的页面。

### 换出
内存页的换出是在`alloc_pages`函数里调用的：不管是新分配一页内存，还是新建页表，还是换入交换区中的一页，只要调用了`alloc_page`（宏，限定`alloc_pages`一次只能分配一页）且`pmm_manager`因为物理内存不足而无法正常分配，就需要调用`swap_out`换出内存页以留出物理页空间。  

下面具体介绍一页被换出经过的处理：  
1. `swap_out`函数首先调用`swap_manager`的`swap_out_victim`函数获取需要被置换出去的页。在FIFO的实现中，是拿出链表最后一个页（`list_prev(head)`，头指针的前一个）将其赋值给二级指针参数。
2. 接着调用`get_pte`拿到该页对应的页表项，使用了一个`assert((*ptep & PTE_V) != 0)`来确保该页是一个有效页。
3. 确定了选出的页是可以被换出的以后，调用`swapfs_write`函数将该页写入磁盘的交换区。该函数同前一样，实际是调用`ide_write_secs`函数将其`memcpy`进交换区。
4. 写入后，将页表项更新为`swap_entry`，方便换入的时候磁盘寻道。
5. 最后，调用`tlb_invalidate`刷新TLB。

## 练习2：深入理解不同分页模式的工作原理

> get_pte() 函数（位于 kern/mm/pmm.c）用于在页表中查找或创建页表项，从而实现对指定线性地址对应的物理页的访问和映射操作。这在操作系统中的分页机制下，是实现虚拟内存与物理内存之间映射关系非常重要的内容。  
函数`get_pte()`的定义如下：

```c
    pde_t *pdep1 = &pgdir[PDX1(la)];
    if (!(*pdep1 & PTE_V)) {
        struct Page *page;
        if (!create || (page = alloc_page()) == NULL) {
            return NULL;
        }
        set_page_ref(page, 1);
        uintptr_t pa = page2pa(page);
        memset(KADDR(pa), 0, PGSIZE);
        *pdep1 = pte_create(page2ppn(page), PTE_U | PTE_V);
    }
    pde_t *pdep0 = &((pde_t *)KADDR(PDE_ADDR(*pdep1)))[PDX0(la)];
//    pde_t *pdep0 = &((pde_t *)(PDE_ADDR(*pdep1)))[PDX0(la)];
    if (!(*pdep0 & PTE_V)) {
    	struct Page *page;
    	if (!create || (page = alloc_page()) == NULL) {
    		return NULL;
    	}
    	set_page_ref(page, 1);
    	uintptr_t pa = page2pa(page);
    	memset(KADDR(pa), 0, PGSIZE);
 //   	memset(pa, 0, PGSIZE);
    	*pdep0 = pte_create(page2ppn(page), PTE_U | PTE_V); //创建一个pte表项
    }
    return &((pte_t *)KADDR(PDE_ADDR(*pdep0)))[PTX(la)];
```

可见该函数主要完成的工作是根据给出的 PDT 基地址以及虚拟地址，找到对应的 PTE ，完成的方式为通过从虚拟地址中提取页目录索引 PDX 以及页表索引 PTX，从而依次找到页目录项 PDE 以及页表项 PTE。

> get_pte() 函数中有两段形式类似的代码，结合 sv32，sv39，sv48 的异同，解释这两段代码为什么如此相像。

`get_pte()`函数中的两段代码看起来非常相似，因为它们都在执行基本相似操作：检查页目录项 PDE （或页表项 PTE）是否存在，如果不存在并且`create`参数为1，则分配一个新的 PDE (或 PTE)，并设置新的PDE（或PTE）的值。对于页目录表的操作同页表的操作是类似的。  
这两段代码之间的主要区别在于它们操作的页目录级别不同。第一段代码处理的是第一级页目录，而第二段代码处理的是第二级页目录（也即页表）。  
在Sv32、Sv39和Sv48这三种虚拟内存方案中，都使用了多级页表来实现虚拟地址到物理地址的映射。Sv32使用两级页表，Sv39使用三级页表，而Sv48使用四级页表。每一级的页表都有一个对应的页目录，这些页目录项存储了下一级页表的物理地址整体的结构都是类似的，都是每个表有一些表项，每个表项指向下一级的表，所以，就会让每级之间的页表查询访问方式相似。

> 目前 get_pte() 函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？

`get_pte()`函数中，首先查询页目录表，再查询页表，从而得到一个 PTE ，在查询页目录表以及页表的过程中，如果表项不为valid，就会根据参数create来决定是否在缺失处创建一个新的表项，以此同时实现查询与分配页表项的功能。  
如果将查询以及分配的功能分开，可以想到，在分配一个页表项时，就需要对该页表项的位置进行查询，所以需要调用查询相关的函数。而查询函数可能会返回一个空的表项，而这个表项可能是 PTE ，也有可能是 PDE ，因为可能此时想要创建的页表项的页表所对应的页目录表项还未建立。这样，其返回结果既可能是需要创建的页表项，也有可能是其上一级的页目录表。从而需要做额外判断，造成逻辑上的复杂性。  
因此如果将函数拆分，最好创建一个函数单独在页目录表中搜索以及一个函数单独在页表中搜索。这样的逻辑是复杂的，我们也往往不需要单独搜索页目录表，而是同时搜索页目录表及其对应的页表。  
所以我们认为这样的写法很好，没有必要把两个函数拆开。

## 练习3：给未被映射的地址映射上物理页

## 练习4：补充完成 Clock 页替换算法

## 练习5：阅读代码和实现手册，理解页表映射方式相关知识
### 大页表优势
1. 简化了页表的层次结构，可以更高效地查找和缓存页表项，提高内存访问性能。
2. 减少了所需页表项的数量，减小了内存管理开销。
3. 对于需要大量连续内存的应用程序，如数据库和深度学习等，能很好地满足其内存需要与性能要求。

### 大页表劣势
1. 内存浪费：多级页表只有在对应的页需要时才会建立页表，而使用大页表的话，即使进程只需很小的内存，也需要分配完整的页表空间。
2. 大页表占据大量内存空间，进程切换需要改变虚拟地址空间，可能导致内存页频繁换入换出，影响性能。
3. 如果使用大页表的话，一页只能存512个页表项，难免会使用比页更大的内存分配单位，容易造成内存碎片问题。

## Challenge：实现不考虑实现开销和效率的 LRU 页替换算法
